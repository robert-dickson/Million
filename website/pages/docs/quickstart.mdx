---
title: 'Quickstart'
description: 'Get started with Million.js'
---

import { Callout, Tabs, Tab, Cards, Card } from 'nextra-theme-docs';
import { Sandpack } from "@codesandbox/sandpack-react";

# Quickstart

Want to just try Million.js out? Open the following link in a new tab to get started with a pre-configured Million.js project:

[![Open in StackBlitz](https://developer.stackblitz.com/img/open_in_stackblitz.svg)](https://stackblitz.com/github/aidenybai/million-react)

## Install Million.js

Otherwise, inside your project directory, run the following command:

{' '}

<Tabs items={['npm', 'pnpm', 'yarn']} storageKey="selected-pkg-manager">
  {/* prettier-ignore */}
  <Tab>
  ```bash copy
  npm install million
  ```
  </Tab>
  {/* prettier-ignore */}
  <Tab>
  ```bash copy
  pnpm install million
  ```
  </Tab>
  {/* prettier-ignore */}
  <Tab>
  ```bash copy
  yarn add million
  ```
  </Tab>
</Tabs>

Then, add the compiler to your bundler of choice:

<Tabs items={['Next.js (beta)', 'Vite', 'Webpack', 'Rollup', 'Rspack', 'Esbuild']} storageKey="selected-bundler-compiler">
  <Tab>
  <Callout>
    Next.js support is currently in beta. Please report any issues you encounter.
  </Callout>
  ```js filename="next.config.mjs"
  import million from 'million/compiler';

  /** @type {import('next').NextConfig} */
  const nextConfig = {
    reactStrictMode: true,
  };

  export default million.next(nextConfig);
  ```
  </Tab>
  <Tab>
  ```js filename="vite.config.js"
  import million from 'million/compiler';
  import { defineConfig } from 'vite';

  export default defineConfig({
    plugins: [million.vite()],
  });
  ```
  </Tab>
  <Tab>
  ```js filename="webpack.config.js"
  import million from 'million/compiler';

  export default {
    plugins: [million.webpack()],
  };
  ```
  </Tab>
  <Tab>
  ```js filename="rollup.config.js"
  import million from 'million/compiler';

  export default {
    plugins: [million.rollup()],
  };
  ```
  </Tab>
  <Tab>
  ```js filename="rspack.config.js"
  // @ts-check
  const { default: million } = require('million/compiler');

  /** @type {import('@rspack/cli').Configuration} */
  module.exports = {
    plugins: [million.rspack()],
  };
  ```
  </Tab>
  <Tab>
  ```js filename="esbuild.config.js"
  import million from 'million/compiler';
  import { build } from 'esbuild';

  build({
    plugins: [million.esbuild()],
  });
  ```
  </Tab>
</Tabs>


## Learn Million.js

Million.js operates off of the concept of "blocks". Imagine blocks as special [Higher Order Components (HOCs)](https://legacy.reactjs.org/docs/higher-order-components.html) that you use in your React application, but are rendered using the Million.js virtual DOM.

In order to create blocks from your components, all you'll need to is wrap your components in a `block(){:jsx}` function.

## `block(Component){:jsx}`

`block(Component){:jsx}` must consume a React component, and returns a Block component.

<Callout>
  Block components must be deterministic, meaning that they must always return the same JSX. However, they can use hooks, any props, and other React features, except passing in JSX as children.
</Callout>

<br />

<Sandpack
  theme="auto"
  options={{
    editorHeight: 500,
    editorWidthPercentage: 70
  }}
  template="vite-react"
  customSetup={{
    dependencies: {
      "react": "latest",
      "million": "latest"
    }
  }}
  files={{
    "vite.config.js": `import million from 'million/compiler';\nimport { defineConfig } from 'vite';\n\nexport default defineConfig({\n  plugins: [million.vite()],\n});`,
    "/index.jsx": `import React, { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import "./styles.css";
import App from "./App";
const root = createRoot(document.getElementById("root"));
root.render(<StrictMode><App /></StrictMode>);`,
    "/App.jsx": `import React, { useState } from 'react';
import { block } from 'million/react';

function App() {
  // ‚úÖ hooks + object props are allowed
  const [count, setCount] = useState(0);

  // ‚úÖ always use a consistent, top level return
  return (
    <button onClick={() => setCount(count + 1)}>
      {count}
    </button>
  );
}

// ‚úÖ always define on a new line
const AppBlock = block(App);

export default AppBlock;`
  }}
/>

Here's some things that are **not allowed:**

```jsx {10, 16, 26, 28-29}
import React, { useState } from 'react';
import { createRoot } from 'react-dom/client';
import { block } from 'million/react';

function IllegalComponent({ name, initial }) {
  const [count, setCount] = useState(initial.count);
  const greeting = `Hello ${name}!`;

  if (count > 10) {
    return <div>Too many clicks!</div>; // ‚ùå don't use conditionals
  }
  return (
    <div>
      {greeting}
      <button onClick={() => setCount(count + 1)}>
        {<div>{count}</div> /* ‚ùå don't pass JSX */}
      </button>
    </div>
  );
}

const IllegalComponentBlock = block(IllegalComponent);

createRoot(document.getElementById('root')).render(<>
  <IllegalComponentBlock name="Sad Jutan" initial={{ count: 0 }}>
    <div>uh oh...</div> // ‚ùå don't pass JSX as props
  </IllegalComponentBlock>,
  // ‚ùå don't use components that have been converted to blocks
  <IllegalComponent />
</>);
```

## Optimized Array Rendering

Similar to how [React uses keys](https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key) to optimize rendering of lists, Million.js uses keys and a special `<For />{:jsx}` component to optimize rendering of arrays, as the following is **NOT allowed**:

```jsx
// ‚ùå not allowed within block
array.map((name) => {
  <div>{name}</div>
});
```

## `<For />{:jsx}`

**Syntax:** `<For each={array}>{(item, index) => Block}</For>{:jsx}`\
**Example:** `<For each={[1, 2, 3]}>{(item, index) => myBlock({ item, index })}</For>{:jsx}`

The `<For />{:jsx}` component is used to render a list of blocks. It takes an array as the `each` prop and a function as its children. The function is called for each item in the array and is passed the item and its index as arguments.

It's the best way to loop over an array (uses [`mapArray(){:jsx}`](/map-array) under the hood). As the array changes, `<For />{:jsx}` updates or moves items in the DOM rather than recreating them. Let's look at an example:

<Sandpack
  theme="auto"
  options={{
    editorHeight: 500,
    editorWidthPercentage: 70
  }}
  template="vite-react"
  customSetup={{
    dependencies: {
      "react": "latest",
      "million": "latest"
    }
  }}
  files={{
    "vite.config.js": `import million from 'million/compiler';\nimport { defineConfig } from 'vite';\n\nexport default defineConfig({\n  plugins: [million.vite()],\n});`,
     "/index.jsx": `import React, { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import "./styles.css";
import App from "./App";
const root = createRoot(document.getElementById("root"));
root.render(<StrictMode><App /></StrictMode>);`,
    "/App.jsx": `import React, { useState } from 'react';
import { block, For } from 'million/react';

function Display({ item }) {
  return <div>{item}</div>;
}

const DisplayBlock = block(Display);

function App() {
  const [items, setItems] = useState([1, 2, 3]);

  const handleClick = () => {
    setItems([...items, items.length + 1]);
  }

  return (
    <div>
      <button onClick={handleClick}>
        Add item
      </button>
      <For each={items}>
        {(item) => <DisplayBlock key={item} item={item} />}
      </For>
    </div>
  );
}

export default App;`
  }}
/>

```jsx {8, 18-20}
import { createRoot } from 'react-dom/client';
import { block, For } from 'million/react';

function Display({ item }) {
  return <div>{item}</div>;
}

const DisplayBlock = block(Display);

function App() {
  const [items, setItems] = useState([1, 2, 3]);

  return (
    <div>
      <button onClick={() => setItems([...items, items.length + 1])}>
        Add item
      </button>
      <For each={items}>
        {(item) => <DisplayBlock key={item} item={item} />}
      </For>
    </div>
  );
}

createRoot(document.getElementById('root')).render(<App />);
```

## You're ready to go! üéâ

Yep, that's all there is to geting started with Million.js. You can now start building your own blocks and use them in your React application.
